// Copyright 2018 Google LLC
// Copyright 2018-present Open Networking Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file includes the proto definitions for test vectors used for blackbox
// testing. For more details see go/blackbox-sw-qual.
// TODO(unknown): This is still WIP. Expect changes etc.
// TODO(unknown): The location of this file is not fixed yet. We need to find
// a better more permanent location for this proto file.
syntax = "proto3";

option cc_generic_services = false;

package google.stratum.testing;

import "p4/v1/p4runtime.proto";
import "openconfig/gnmi/proto/gnmi/gnmi.proto";

//////////////////////////////////////////////
// P4Runtime related messaged
//////////////////////////////////////////////

message ControlPlaneOperation {
  message WriteOperation {
    // The write request to program all the forwarding entries and its
    // corresponding RPC response.
    p4.v1.WriteRequest p4_write_request = 1;
    p4.v1.WriteResponse p4_write_response = 2;
  }
  message PacketOutOperation {
    // Defines the packet to be sent by the SDN controller to a dataplane port
    // or ingress pipeline. The packets are received by the P4Runtime agent and
    // sent to the switching chip via its CPU port.
    p4.v1.PacketOut p4_packet_out = 1;
    // Number of packets to be sent out. A negative number refers to "continuous
    // mode".
    int64 num_of_packets = 2;
    // "min" and "max" speed at which packets will be sent to the CPU port.
    // Makes sense only if multiple packets are egressed. A zero speed means
    // "dont care".
    uint64 min_speed_bps = 3;
    uint64 max_speed_bps = 4;
    // class of service of the packets.
    int32 cos = 5;
  }
  message PipelineConfigOperation {
    // The forwarding pipeline config to push to the switch, to test setting
    // and/or mutating the config directly via P4Runtime API, and its expected
    // RPC response. Note that forwarding pipeline config is also set via gNMI.
    p4.v1.SetForwardingPipelineConfigRequest
        p4_set_pipeline_config_request = 1;
    p4.v1.SetForwardingPipelineConfigResponse
        p4_set_pipeline_config_response = 2;
  }
  oneof operations {
    WriteOperation write_operation = 1;
    PacketOutOperation packet_out_operation = 2;
    PipelineConfigOperation pipeline_config_operation = 3;
  }
}

message ControlPlaneExpectation {
  message ReadExpectation {
    p4.v1.ReadRequest p4_read_request = 1;
    // Set of ReadResponse protos read from the streaming channel. Note that
    // for the case of Read RPC, channel has to close after all these responses
    // are sent back.
    repeated p4.v1.ReadResponse p4_read_responses = 2;
  }
  message PacketInExpectation {
    // Defines the packet to be received on the CPU port and sent to the SDN
    // SDN controller.
    p4.v1.PacketIn p4_packet_in = 1;
    // number of packets to be received. A negative number refers to "continuous
    // mode".
    int64 num_of_packets = 2;
    // "min" and "max" speed at which packets will be received at CPU port.
    // Makes sense if multiple packets are ingressed. A zero speed means "dont
    // care". If min and max speeds are the same and positive, the measured
    // speed will be strictly checked to be the same as the value specified.
    // Expected speeds are are typically specified to test rate limiting.
    uint64 min_speed_bps = 3;
    uint64 max_speed_bps = 4;
    // class of service of the packets.
    int32 cos = 5;
  }
  message PipelineConfigExpectation {
    p4.v1.GetForwardingPipelineConfigRequest p4_get_pipeline_config_request = 1;
    p4.v1.GetForwardingPipelineConfigResponse
        p4_get_pipeline_config_response = 2;
  }
  oneof expectations {
    ReadExpectation read_expectation = 1;
    PacketInExpectation packet_in_expectation = 2;
    PipelineConfigExpectation pipeline_config_expectation = 3;
  }
}

message DataPlaneStimulus {
  // Defines the external data plane traffic stimulus. To be generated by a
  // traffic gen and sent to a port (ingress to switch). There will be one flow
  // per port.
  message TrafficStimulus {
    message Packet {
      // raw packet
      bytes payload = 2;
    }
    // The ID of the node/device (defined in the config pushed beforehand via
    // gNMI).
    uint64 device_id = 1;
    // SDN port/trunk number (defined in the config pushed beforehand via gNMI).
    uint32 port = 2;
    // The packets to be sent to the port one after another. The order of the
    // repeated field defines the order in which the packets will be sent to the
    // port by the traffic gen.
    repeated Packet packets = 3;
    // The # of times traffic generators sends all the packet (defined by
    // "packets" above) to the port. A negative number refers to "continuous
    // mode".
    int64 num_of_replicas = 4;
    // "min" and "max" speed at which the packets will be generated by traffic
    // gen. Defines an interval for the acceptable rate for the generated
    // packets.
    uint64 min_speed_bps = 5;
    uint64 max_speed_bps = 6;
    // class of service for the generated packet.
    int32 cos = 7;
  }
  oneof stimuli {
    TrafficStimulus traffic_stimulus = 1;
  }
}

message DataPlaneExpectation {
  message TrafficExpectation {
    // Define packet out distribution in case packets are sent to an ECMP group
    // ( i.e. more than one output ports are given).
    message Distribution {
      // TODO
    }
    message Packet {
      // raw packet
      bytes payload = 2;
    }
    // The ID of the node/device (defined in the config pushed beforehand via
    // gNMI).
    uint64 device_id = 1;
    // Output packet may come out of one of these ports
    repeated uint32 ports = 2;
    // The packets to come out of the port(s) one after another. The order of
    // the repeated field defines the order in which the packets will be
    // egressed.
    repeated Packet packets = 3;
    // The # of times all the packet (defined by "packets" above) will be sent
    // out of the port(s). A negative number refers to "continuous mode".
    int64 num_of_replicas = 4;
    // Speed at which the packets will be sent out of the port(s). Defines an
    // interval for the acceptable rate for the received packets. If min and max
    // speeds are the same and positive, the measured speed will be strictly
    // checked to be the same as the value specified.
    uint64 min_speed_bps = 5;
    uint64 max_speed_bps = 6;
    // Packet distribution. Dont care if there is one egress port. Used to test
    // hashing.
    Distribution distribution = 7;
    // class of service of the packets.
    int32 cos = 8;
  }
  oneof expectations {
    TrafficExpectation traffic_expectation = 1;
  }
}

//////////////////////////////////////////////
// gNMI related messaged
//////////////////////////////////////////////

// Config push, port speed change, port admin state change, trunk pruning.
message ConfigOperation {
  gnmi.SetRequest gnmi_set_request = 1;
  gnmi.SetResponse gnmi_set_response = 2;
}

// Signal to a possibly external device to change the state of a port (aka
// interface). Note that this is different from changing the admin state of a
// port which is done via Set RPC.
message PortStimulus {
  enum State {
    STATE_UNKNOWN = 0;
    STATE_UP = 1;           // Port up.
    STATE_DOWN = 2;         // Port down (different from not present)
    STATE_NOT_PRESENT = 3;  // emulate QSFFP module removal
  }
  gnmi.Path interface = 1;
  State state = 2;
}

// Signal to a possibly external device to simulate an alarm situation.
message AlarmStimulus {
  gnmi.Path alarm = 1;
  // TODO(unknown): Complete the proto.
}

message ConfigExpectation {
  gnmi.GetRequest gnmi_get_request = 1;
  gnmi.GetResponse gnmi_get_response = 2;
}

message TelemetryExpectation {
  // As part of each telemetry expectation, we open a "new" subscription
  // channel, send one SubscribeRequest, optionally do some actions (operations
  // or stimuli), and verify the SubscribeResponse messages we read from the
  // stream. Note that TelemetryExpectation is the only expectation message that
  // includes the actions as part of it, as it needs to specify the actions done
  // after the streaming channel is created (actions before channel creation are
  // already part of an external ActionGroup message, no need to put them here).
  // The SubscribeResponse messages are read using a different thread, that is
  // spawned as soon as the stream is opened, before sending any request.
  // Anything read from the channel is saved with exact timestamp for later
  // verification. We clearly specify what needs to be read from the channel as
  // part of the test. We also make sure all the requirements (e.g. timing
  // requirements) are specified as well. Note that even in case of streaming a
  // leaf value with certain frequency, we can limit the number of protos read
  // from the channel within a certain period of time. Here is an example:
  // -  Port status test over gNMI: Specify a timeout for the port event,
  //    specify a series of port UP/DOWN stimulus (using PortStimulus above) in
  //    action_group, in gnmi_subscribe_request specify that you want to
  //    subscribe to a specific interface port state leaf, and finally specify
  //    the series of messages you expect to receive over the stream in
  //    gnmi_subscribe_response. The test client will create a stream channel
  //    and start listening to messages in a separate thread. Sends the requests
  //    over the stream and logs the responses. If it detects the port event
  //    sequence exactly the way it was described within the time out, the test
  //    passes. Otherwise it fails.
  message Requirement {
    // timing requirements, etc for actions.
    // TODO(unknown): add
  }
  Requirement requirement = 1;
  // The single gNMI write request to send over the stream.
  gnmi.SubscribeRequest gnmi_subscribe_request = 2;
  // All the operations and/or stimuli to be run "after" the stream is created
  // and request has been sent. Optional. Not all the TVs will have this field
  // populated. Also, note that we can assume one can run "any" action here
  // (even a config push to packet I/O).
  ActionGroup action_group = 3;
  // The minimum set of SubscribeResponse to be read from the stream "as soon
  // as it is created (not after sending the request). The order should match
  // the order of the messages read from the channel. As soon as these
  // protos are read from the channel within the specified timeout, we close
  // the channel set the test as PASSED. If timeout is reached before reading
  // all these messages, or if there is any other issue while reading the
  // messages, we still close the channel but set the test as FAILED.
  repeated gnmi.SubscribeResponse gnmi_subscribe_response = 4;
}

//////////////////////////////////////////////
// gNOI related messaged
//////////////////////////////////////////////

message SecurityOperation {
  // TODO
}

message DiagOperation {
  // TODO
}

message SystemOperation {
  // TODO
}

message FileOperation {
  // TODO
}

message ManagementOperation {
  oneof flows {
    SecurityOperation security_operation = 1;
    DiagOperation diag_operation = 2;
    SystemOperation system_operation = 3;
    FileOperation file_operation = 4;
  }
}

//////////////////////////////////////////////
// The definition of the test cases and vectors
//////////////////////////////////////////////

// An action is either an operation or an external stimulus that affects the
// SUT.
message Action {
  message Requirement {
    // timing requirements, etc for actions.
    // TODO(unknown): add
  }
  Requirement requirement = 1;
  oneof actions {
    ConfigOperation config_operation = 2;
    ControlPlaneOperation control_plane_operation = 3;
    DataPlaneStimulus data_plane_stimulus = 4;
    ManagementOperation management_operation = 5;
    PortStimulus port_stimulus = 6;
    AlarmStimulus alarm_stimulus = 7;
  }
}

message Expectation {
  oneof expectations {
    ConfigExpectation config_expectation = 1;
    ControlPlaneExpectation control_plane_expectation = 2;
    DataPlaneExpectation data_plane_expectation = 3;
    TelemetryExpectation telemetry_expectation = 4;
  }
  // A unique identifier for the expectation. The main purpose is to be able to
  // find the expectation in the text file upon a failure.
  string expectation_id = 5;
}

// A group of actions to be run sequentially.
message SequentialActionGroup {
  repeated Action actions = 1;
}

// A group of actions to be run in parallel.
message ParallelActionGroup {
  message Options {
    // defines the parallelism options.
    // TODO(unknown): Add this
  }
  Options options = 1;
  repeated Action actions = 2;
}

// A group of actions to be run randomly.
message RandomizedActionGroup {
  message Options {
    // defines the randomization options.
    // TODO(unknown): Add this
  }
  Options options = 1;
  repeated Action actions = 2;
}

message ActionGroup {
  oneof action_group {
    SequentialActionGroup sequential_action_group = 1;
    ParallelActionGroup parallel_action_group = 2;
    RandomizedActionGroup randomized_action_group = 3;
  }
  // A unique identifier for the action group. The main purpose is to be able to
  // find the action group in the text file upon a failure.
  string action_group_id = 4;
}

message TestCase {
  // Set of actions (operations or external stimuli) to be run on the SUT.
  // Actions are bundled into groups with specific orders.
  repeated ActionGroup action_groups = 1;
  // Set of expectations "after" actions are all run.
  // 1- The test will not exercise the expectation if any of the operation
  // fails. 3- Checking expectations must not have any side effects on the
  // switch. 2- The test is expected to check all the expectations and return
  // the overall status including all the expectations that were not met.
  repeated Expectation expectations = 2;
  // A unique identifier for the test case. The main purpose is to be able to
  // find the test case in the text file upon a failure.
  string test_case_id = 3;
}

// Defines the properties of the SUT which are required by the test vectors.
message Target {
  // TODO
}

message TestVector {
  // Info on the target switch.
  Target target = 1;
  // All the test cases which will be run on the switch. Order is important.
  repeated TestCase test_cases = 2;
}
