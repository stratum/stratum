/*
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef STRATUM_HAL_LIB_PHAL_ATTRIBUTE_DATABASE_INTERFACE_H_
#define STRATUM_HAL_LIB_PHAL_ATTRIBUTE_DATABASE_INTERFACE_H_

#include <functional>
#include <memory>
#include <tuple>
#include <vector>

#include "stratum/hal/lib/phal/db.pb.h"
#include "stratum/lib/channel/channel.h"
#include "stratum/glue/integral_types.h"
#include "absl/container/flat_hash_map.h"
#include "absl/types/variant.h"
#include "util/hash/mix.h"
#include "stratum/glue/status/statusor.h"
#include "google/protobuf/descriptor.h"

namespace stratum {
namespace hal {
namespace phal {
using Attribute =
    absl::variant<int32, int64, uint32, uint64, float, double, bool,
                  std::string, const google::protobuf::EnumValueDescriptor*>;

// TODO: Add an 'optional' flag to PathEntry. This flag indicates
// that it is okay to skip querying this path if the marked PathEntry is not
// present in the database.
struct PathEntry {
  PathEntry(const std::string& name, int index, bool indexed, bool all,
            bool terminal_group)
      : name(name),
        index(index),
        indexed(indexed),
        all(all),
        terminal_group(terminal_group) {}
  // Constructs a PathEntry for an attribute with an empty name. This PathEntry
  // is not valid, and its fields must be set after construction.
  PathEntry() : PathEntry("", -1, false, false, false) {}
  // Constucts a PathEntry for an attribute with the given name.
  explicit PathEntry(const std::string& name)
      : PathEntry(name, -1, false, false, false) {}
  // Constructs a PathEntry for the given index into a repeated attribute group.
  PathEntry(const std::string& name, int index)
      : PathEntry(name, index, true, false, false) {}

  std::string name;
  int index = -1;  // This field is only significant if indexed == true.
  bool indexed = false;  // If true, this is a repeated attribute group.
  bool all = false;  // If true, this is a repeated group, but ignore index and
                     // fetch all indices.
  bool terminal_group = false;  // In true, fetch below this attribute group.

  bool operator<(const PathEntry& other) const {
    if (name != other.name) return name < other.name;
    return index < other.index;
  }

  bool operator==(const PathEntry& other) const {
    return name == other.name && index == other.index &&
           indexed == other.indexed && all == other.all &&
           terminal_group == other.terminal_group;
  }
};

typedef std::vector<PathEntry> Path;

struct PathHasher {
  size_t operator()(const stratum::hal::phal::Path& path) const {
    HashMix mix(0);
    for (const auto& path_entry : path)
      mix.Mix(std::hash<std::string>()(path_entry.name));
    return mix.get();
  }
};
// A map used when setting values in the attribute database. We use a custom
// hasher since Path values are not hashable by default.
using AttributeValueMap = absl::flat_hash_map<Path, Attribute, PathHasher>;

// A single query into an attribute database, generated by calling
// AttributeDatabaseInterface::MakeQuery. Queries the set of database paths
// passed into MakeQuery.
class Query {
 public:
  virtual ~Query() {}
  // Returns a proto containing any requested fields in the database. All query
  // fields are considered optional, so missing fields are not populated. Note
  // that subsequent calls to Get() will query the system for attribute values
  // multiple times, and may return different results.
  virtual ::util::StatusOr<std::unique_ptr<PhalDB>> Get() = 0;
  // Subscribes to changes in the result of this query. A message will
  // immediately be sent with the initial value of the query. Subsequent
  // messages are sent whenever the result of the query changes, with an effort
  // to ensure that no longer than the given polling_interval elapses before a
  // change is noticed. If no change has occurred after the polling interval, a
  // message is not sent. If a message would be sent but the channel buffer is
  // full, the message is dropped. Note that messages may be sent more
  // frequently than the given polling interval.
  virtual ::util::Status Subscribe(
      std::unique_ptr<ChannelWriter<PhalDB>> subscriber,
      absl::Duration polling_interval) = 0;

 protected:
  Query() {}
};

// Allows simple access to a database of system attributes.
//
// This interface is likely to change significantly to support better error
// reporting, and/or other unforseen use cases.
class AttributeDatabaseInterface {
 public:
  virtual ~AttributeDatabaseInterface() {}
  // TODO: Implement and document Set. This interface will likely
  // change.
  virtual ::util::Status Set(const AttributeValueMap& values) = 0;
  // Creates a new query that reads the given query paths. The results of this
  // query may be accessed by calling Get() or Subscribe(...) on the returned
  // Query. If a query is returned, this query will remain valid until it is
  // deleted, and values returned by Get() will reflect any updates to the
  // database structure.
  virtual ::util::StatusOr<std::unique_ptr<Query>> MakeQuery(
      const std::vector<Path>& query_paths) = 0;

 protected:
  AttributeDatabaseInterface() {}
};
}  // namespace phal
}  // namespace hal
}  // namespace stratum

#endif  // STRATUM_HAL_LIB_PHAL_ATTRIBUTE_DATABASE_INTERFACE_H_
